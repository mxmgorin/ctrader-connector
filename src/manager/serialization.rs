use crate::manager::common_messages_external::ProtoMessage;
use crate::manager::common_model_messages_external::ProtoPayloadType;
use async_trait::async_trait;
use my_tcp_sockets::{
    socket_reader::{ReadingTcpContractFail, SocketReader},
    TcpContract, TcpSerializerFactory, TcpSerializerState, TcpSocketSerializer, TcpWriteBuffer,
};

pub struct ManagerApiSerializer {}

impl ManagerApiSerializer {
    pub fn new() -> Self {
        Self {}
    }
}

pub struct ManagerApiSerializerState {}

impl TcpSerializerState<ProtoMessage> for ManagerApiSerializerState {
    fn is_tcp_contract_related_to_metadata(&self, _contract: &ProtoMessage) -> bool {
        println!("is_tcp_contract_related_to_metadata");
        // todo
        false
    }

    fn apply_tcp_contract(&mut self, _contract: &ProtoMessage) {
        println!("apply_tcp_contract");
        // todo
    }
}

#[async_trait]
impl TcpSocketSerializer<ProtoMessage, ManagerApiSerializerState> for ManagerApiSerializer {
    fn serialize(
        &self,
        out: &mut impl TcpWriteBuffer,
        contract: &ProtoMessage,
        _state: &ManagerApiSerializerState,
    ) {
        // Sending messages to the proxy follows the same basic principles as receiving, in that
        // the payload should be wrapped within the ProtoMessage structure,
        // and a 4-byte array indicating the length prepended to the generated byte array.
        let mut message_bytes = vec![];
        prost::Message::encode(contract, &mut message_bytes).unwrap();
        let len = message_bytes.len() as i32;
        out.write_byte_array(&len.to_be_bytes()); // todo: what type of bytes? must be reversed?
        out.write_byte_array(&message_bytes[..]);
    }

    fn get_ping(&self) -> ProtoMessage {
        ProtoMessage {
            payload_type: ProtoPayloadType::PingReq as u32,
            payload: None,
            client_msg_id: None,
        }
    }

    async fn deserialize<TSocketReader: Send + Sync + 'static + SocketReader>(
        &mut self,
        socket_reader: &mut TSocketReader,
        _state: &ManagerApiSerializerState,
    ) -> Result<ProtoMessage, ReadingTcpContractFail> {
        println!("deserialize");

        // When reading messages from the stream, the first 4 bytes indicate the length of the actual data.
        // The message which follows is always wrapped within the ProtoMessage structure.
        let len = socket_reader.read_i32().await;
        println!("len: {:?}", len);
        let mut data = Vec::with_capacity(len.unwrap() as usize);
        socket_reader.read_buf(&mut data[..]).await?;
        let message: ProtoMessage = prost::Message::decode(&data[..]).unwrap();

        Ok(message)
    }
}

impl TcpContract for ProtoMessage {
    fn is_pong(&self) -> bool {
        println!("is_pong");

        self.payload_type == ProtoPayloadType::PingRes as u32
    }
}

pub struct ManagerApiSerializerFactory {}

#[async_trait]
impl TcpSerializerFactory<ProtoMessage, ManagerApiSerializer, ManagerApiSerializerState>
    for ManagerApiSerializerFactory
{
    async fn create_serializer(&self) -> ManagerApiSerializer {
        ManagerApiSerializer::new()
    }

    async fn create_serializer_state(&self) -> ManagerApiSerializerState {
        ManagerApiSerializerState {}
    }
}
