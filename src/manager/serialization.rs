use crate::manager::common_messages_external::ProtoMessage;
use async_trait::async_trait;
use my_tcp_sockets::{
    socket_reader::{ReadBuffer, ReadingTcpContractFail, SocketReader},
    TcpContract, TcpSerializerFactory, TcpSerializerState, TcpSocketSerializer, TcpWriteBuffer,
};

pub struct ManagerApiSerializer {
    read_buffer: ReadBuffer,
}

impl ManagerApiSerializer {
    pub fn new() -> Self {
        Self {
            read_buffer: ReadBuffer::new(1024 * 24),
        }
    }
}

pub struct ManagerApiSerializerState {}

impl TcpSerializerState<ManagerApiMessage> for ManagerApiSerializerState {
    fn is_tcp_contract_related_to_metadata(&self, contract: &ManagerApiMessage) -> bool {
        println!("is_tcp_contract_related_to_metadata");
        // todo
        false
    }

    fn apply_tcp_contract(&mut self, contract: &ManagerApiMessage) {
        println!("apply_tcp_contract");
        // todo
    }
}

#[async_trait]
impl TcpSocketSerializer<ManagerApiMessage, ManagerApiSerializerState> for ManagerApiSerializer {
    fn serialize(
        &self,
        out: &mut impl TcpWriteBuffer,
        contract: &ManagerApiMessage,
        _state: &ManagerApiSerializerState,
    ) {
        // Sending messages to the proxy follows the same basic principles as receiving, in that
        // the payload should be wrapped within the ProtoMessage structure,
        // and a 4-byte array indicating the length prepended to the generated byte array.
        let mut message_bytes = vec![];
        let bytes = contract.as_bytes().unwrap();
        let proto_message = ProtoMessage {
            payload_type: 0,
            payload: Some(bytes),
            client_msg_id: None,
        };
        prost::Message::encode(&proto_message, &mut message_bytes).unwrap();
        let len = message_bytes.len() as i32;
        out.write_byte_array(&len.to_be_bytes()); // todo: what type of bytes? must be reversed?
        out.write_byte_array(&message_bytes[..]);
    }

    fn get_ping(&self) -> ManagerApiMessage {
        println!("get_ping");

        ManagerApiMessage::HeartbeatEvent
    }

    async fn deserialize<TSocketReader: Send + Sync + 'static + SocketReader>(
        &mut self,
        socket_reader: &mut TSocketReader,
        state: &ManagerApiSerializerState,
    ) -> Result<ManagerApiMessage, ReadingTcpContractFail> {
        println!("deserialize");

        // When reading messages from the stream, the first 4 bytes indicate the length of the actual data.
        // The message which follows is always wrapped within the ProtoMessage structure.
        let len = socket_reader.read_i32().await?;
        println!("len: {:?}", len);
        let mut data = Vec::with_capacity(len as usize);
        socket_reader.read_buf(&mut data[..]).await?;
        let message: ProtoMessage = prost::Message::decode(&data[..]).unwrap();

        Ok(message.into())
    }
}

impl From<ProtoMessage> for ManagerApiMessage {
    fn from(value: ProtoMessage) -> Self {
        // todo
        ManagerApiMessage::Todo
    }
}

impl ManagerApiMessage {
    pub fn as_bytes(&self) -> Result<Vec<u8>, prost::EncodeError> {
        let mut result = vec![];
        // todo
        //prost::Message::encode(self, &mut result)?;
        Ok(result)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum ManagerApiMessage {
    Todo,
    HelloEvent,
    HeartbeatEvent,
}

impl TcpContract for ManagerApiMessage {
    fn is_pong(&self) -> bool {
        println!("is_pong");

        matches!(self, ManagerApiMessage::HeartbeatEvent)
    }
}

pub struct ManagerApiSerializerFactory {}

#[async_trait]
impl TcpSerializerFactory<ManagerApiMessage, ManagerApiSerializer, ManagerApiSerializerState>
    for ManagerApiSerializerFactory
{
    async fn create_serializer(&self) -> ManagerApiSerializer {
        ManagerApiSerializer::new()
    }

    async fn create_serializer_state(&self) -> ManagerApiSerializerState {
        ManagerApiSerializerState {}
    }
}
